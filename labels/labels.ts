import readline from "readline"
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';

type LabelFileLine = string | [string, string, string];

export const MEDIA_DIRECTORY = path.join(__dirname, '..', 'media');

export const LABEL_FILES = [
  'legacy-media.txt', // files from legacy media from Solero
  'vanilla-media.txt', // files from vanilla media from Solero
  'archives.txt', // files from cparchives (basically original files)
  'modified.txt', // files MODDED for Waddle Forever specifically
  'recreations.txt', // files recreated (for Waddle Forever or not)
  'autogenerated.txt', // files autogenerated eg. global crumbs
  'unknown.txt', // files of no known origin
  'mammoth.txt' // files from the mammoth 2006/04 media server
];

export class LabelFile {
  private _lines: Array<LabelFileLine>
  private _hashMap: Map<string, number>
  private _pathMap: Map<string, number>
  private _filePath: string;

  private constructor(lines: LabelFileLine[], filePath: string) {
    this._lines = lines;
    this._hashMap = new Map<string, number>();
    this._pathMap = new Map<string, number>();
    this._filePath = filePath;
    this._lines.forEach((line, index) => {
      if (typeof line !== 'string') {
        const [path, hash] = line;
        this._hashMap.set(hash, index);
        this._pathMap.set(path, index);
      }
    });
  }

  static async fromFile(file: string): Promise<LabelFile> {
    const lines: LabelFileLine[] = [];
    await new Promise<Map<string, string>>((resolve) => {
      const lineReader = readline.createInterface({
        input: fs.createReadStream(file)
      });
    
      const files = new Map<string, string>();
    
      let number = 0;
      lineReader.on('line', (line) => {
        number++;
        // three possible allowed lines in this file:
        // 1. start with hyphen (comment, ignore)
        if (line.startsWith('-')) {
          lines.push(line);
        } else if (line.match(/^\s*$/) !== null) { // 2. white space only (ignore)
          lines.push(line);
        } else {
          // starts with file path and name (capture)
          // group 1 is the filepath
          // group 2 is the md5 hash (separated via colon)
          // group 3 is either ending the line (nothing) or a comment
          const fileMatch = line.match('^([\\w\\d\\_\\-/\\.\\#]+)\\:([a-fA-F0-9]*)($|\\s+\\-.*)');
          
          // no match means the line doesn't conform to any thing we allow
          if (fileMatch === null) {
            throw new Error(`Invalid line for file ${file}, line ${number}: ${line}`);
          } else {
            const fileName = fileMatch[1];
            const hash = fileMatch[2];
            const comment = fileMatch[3];
            lines.push([fileName, hash, comment]);

          }
        }
      });
  
      lineReader.on('close', () => {
        resolve(files);
      });
    })
    
    return new LabelFile(lines, file);
  }

  checkFilesExistence(): void {
    this._pathMap.forEach((_, file) => {
      if (fs.existsSync(path.join(MEDIA_DIRECTORY, file))) {
      } else {
        throw new Error(`Labeled file does not exist: ${file}`);
      }
    })
  }

  getFileMap(): Map<string, string> {
    const map = new Map<string, string>();
    this._lines.forEach((line) => {
      if (typeof line !== 'string') {
        const [path, hash] = line;
        map.set(path, hash);
      }
    });

    return map;
  }

  updatePath(oldPath: string, newPath: string): void {
    const index = this._pathMap.get(oldPath);
    if (index === undefined) {
      throw new Error(`Old path not found: ${oldPath}`);
    }
    const [_, hash, comment] = this._lines[index];
    this._lines[index] = [newPath, hash, comment];
  }

  write(): void {
    let fileContent = '';
    this._lines.forEach((line) => {
      if (typeof line === 'string') {
        fileContent += line + '\n';
      } else {
        const [path, hash, comment] = line;
        fileContent += `${path}:${hash}${comment}`;
      }
    });

    fs.writeFileSync(this._filePath, fileContent);
  }
}

function getFilesInDirectory(basePath: string, relativePath: string): string[] {
  const fileNames: string[] = [];
  const absolutePath = path.join(basePath, relativePath);
  const files = fs.readdirSync(absolutePath);
  files.forEach((file) => {
    const fileAbsolutePath = path.join(absolutePath, file);
    const fileRelativePath = path.join(relativePath, file);
    if (fs.lstatSync(fileAbsolutePath).isDirectory()) {
      const childFiles = getFilesInDirectory(basePath, fileRelativePath);
      fileNames.push(...childFiles);
    } else {
      fileNames.push(fileRelativePath);
    }
  })

  return fileNames;
}

export function getEveryMediaFile(): Map<string, string> {
  const files = getFilesInDirectory(MEDIA_DIRECTORY, '');
  const map = new Map<string, string>();
  const reversed = new Map<string, string>();
  files.forEach((file) => {
    const hash = crypto.createHash('md5').update(fs.readFileSync(path.join(MEDIA_DIRECTORY, file), { encoding: 'utf-8' })).digest('hex')
    const cleanName = file.replaceAll('\\', '/')
    if (reversed.has(hash)) {
      // console.error(`File of hash ${hash} is duplicated in the media files`)
    }
    map.set(cleanName, hash);
    reversed.set(hash, cleanName);
  });

  return map;
}

/** Read a file path in the label style and get all files that are labeled in it */
export async function processLabelFile(filePath: string): Promise<Map<string, string>> {
  const labelFile = await LabelFile.fromFile(filePath);
  labelFile.checkFilesExistence();
  
  return labelFile.getFileMap();
}