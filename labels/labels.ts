import readline from "readline"
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';

// for timing script execution
const startTime = Date.now();

/**
 * This module handles making sure every file in the game is properly labeled
 * Runs this script and you can get a list of every unlabeled file outputed!
 */

const MEDIA_DIRECTORY = path.join(__dirname, '..', 'media');

/** Read a file path in the label style and get all files that are labeled in it */
function processLabelFile(filePath: string): Promise<Map<string, string>> {
  return new Promise<Map<string, string>>((resolve) => {

    const lineReader = readline.createInterface({
      input: fs.createReadStream(filePath)
    });
  
    const files = new Map<string, string>();
  
    let number = 0;
    lineReader.on('line', (line) => {
      number++;
      // three possible allowed lines in this file:
      // 1. start with hyphen (comment, ignore)
      if (line.startsWith('-')) {
        return;
      } else if (line.match(/^\s*$/) !== null) { // 2. white space only (ignore)
        return;
      } else {
        // starts with file path and name (capture)
        // group 1 is the filepath
        // group 2 is the md5 hash (separated via colon)
        const fileMatch = line.match('^([\\w\\d\\_\\-/\\.]+)\\:([a-fA-F0-9]*)');
        
        // no match means the line doesn't conform to any thing we allow
        if (fileMatch === null) {
          throw new Error(`Invalid line for file ${filePath}, line ${number}: ${line}`);
        } else {
          const fileName = fileMatch[1];
          const hash = fileMatch[2];
          if (fs.existsSync(path.join(MEDIA_DIRECTORY, fileName))) {
            files.set(fileName, hash);
          } else {
            throw new Error(`Labeled file does not exist: ${fileName}`);
          }
        }
      }
    });

    lineReader.on('close', () => {
      resolve(files);
    });
  })
}

function getFilesInDirectory(basePath: string, relativePath: string): string[] {
  const fileNames: string[] = [];
  const absolutePath = path.join(basePath, relativePath);
  const files = fs.readdirSync(absolutePath);
  files.forEach((file) => {
    const fileAbsolutePath = path.join(absolutePath, file);
    const fileRelativePath = path.join(relativePath, file);
    if (fs.lstatSync(fileAbsolutePath).isDirectory()) {
      const childFiles = getFilesInDirectory(basePath, fileRelativePath);
      fileNames.push(...childFiles);
    } else {
      fileNames.push(fileRelativePath);
    }
  })

  return fileNames;
}

function getEveryMediaFile(): Map<string, string> {
  const files = getFilesInDirectory(MEDIA_DIRECTORY, '');
  const map = new Map<string, string>();
  files.forEach((file) => {
    const hash = crypto.createHash('md5').update(fs.readFileSync(path.join(MEDIA_DIRECTORY, file), { encoding: 'utf-8' })).digest('hex')
    const cleanName = file.replaceAll('\\', '/')
    map.set(cleanName, hash);
  });

  return map;
}

const LABEL_FILES = [
  'legacy-media.txt', // files from legacy media from Solero
  'vanilla-media.txt', // files from vanilla media from Solero
  'archives.txt', // files from cparchives (basically original files)
  'modified.txt', // files MODDED for Waddle Forever specifically
  'recreations.txt', // files recreated (for Waddle Forever or not)
  'autogenerated.txt', // files autogenerated eg. global crumbs
  'unknown.txt', // files of no known origin
  'mammoth.txt', // files from the mammoth 2006/04 media server
];

const labeledFiles = new Map<string, string>();

async function addLabeledFiles(file: string): Promise<void> {
  const files = await processLabelFile(path.join(__dirname, 'groups', file));
  files.forEach((hash, file) => {
    if (labeledFiles.has(file)) {
      throw new Error(`A file which has been labeled multiple times has been found: ${file}`);
    } else {
      labeledFiles.set(file, hash);
    }
  });
}

// adding all labeled files, once that's done we finish the process
Promise.all(LABEL_FILES.map((file) => addLabeledFiles(file))).then(() => {
  const everyFile = getEveryMediaFile();
  const nonLabeledFiles = new Map<string, string>();
  
  everyFile.forEach((hash, file) => {
    const labeledHash = labeledFiles.get(file);
    // if file is not found, then it's unlabeled
    if (labeledHash === undefined) {
      nonLabeledFiles.set(file, hash);
    } else {
      // if found, check if it's the same file
      if (hash !== labeledHash) {
        nonLabeledFiles.set(file, hash);
      }
    }
  });
  
  const unlabeledArray = Array.from(nonLabeledFiles.entries()).map((pair) => {
    return `${pair[0]}:${pair[1]}`
  });
  
  const unlabeledAmount = unlabeledArray.length;
  const totalAmount = Array.from(everyFile.values()).length;
  const endTime = Date.now();
  const secondsTaken = (endTime - startTime) / 1000;
  
  if (unlabeledAmount < 20) {
    unlabeledArray.forEach((file) => console.log(file));
  }

  fs.writeFileSync(path.join(__dirname, 'unlabeled.txt'), unlabeledArray.join('\n'));
  console.log(`Unlabeled search complete. ${unlabeledAmount} unlabeled files found out of ${totalAmount} (${unlabeledAmount}/${totalAmount})`);
  
  console.log(`Total time taken: ${secondsTaken}`);

});
