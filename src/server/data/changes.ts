import { isEqual, isLower, Version } from "../routes/versions"

export type PermanentChange<ChangeInformation> = {
  date: Version;
  info: ChangeInformation
};

export type TemporaryChange<ChangeInformation> = {
  date: Version;
  end: Version;
  info: ChangeInformation;
  updates: Array<PermanentChange<ChangeInformation>>;
};

/** Abstraction of a type that represents either a temporary event or permanent one in a timeline */
export type TimelineEvent<ChangeInformation> = PermanentChange<ChangeInformation> | TemporaryChange<ChangeInformation>;

/**
 * Processes a timeline of events into some form of output
 * @param timeline The timeline of events
 * @param getInput A function that takes each event and gets characteristic input data that is meant to be particular of each event
 * @param getOutput A function that takes a previous' event input data, or none if nothing previous, and the current event input data and outputs a final output
 * @param hashOutput A function that creates a unique identifier for a given output, to be able to hash it
 * @returns 
 */
export function processTimeline<EventInformation, EventInput, EventOutput>(
  timeline: TimelineEvent<EventInformation>[],
  getInput: <T extends EventInformation>(input: T) => EventInput,
  getFirstOutput: () => EventOutput,
  getOutput: (prev: EventOutput, cur: EventInput) => EventOutput,
  hashOutput: (out: EventOutput) => string
): Array<{
  date: Version,
  out: EventOutput,
  id: number
}> {
  // first part of this altgothrm:
  // labeling what each update is and breaking everything down
  // to events
  
  // get id of event input so we can find them later
  const permanentMapping = new Map<number, EventInput>();
  const temporaryMapping = new Map<number, EventInput>();

  const eventsTimeline: Array<{
    type: 'permanent' | 'temp_start' | 'temp_end',
    id: number;
    date: Version;
  }> = [];

  let currentId = 0;

  timeline.forEach((event) => {
    if ('end' in event) {
      currentId++;
      temporaryMapping.set(currentId, getInput(event.info));
      eventsTimeline.push({
        type: 'temp_start',
        id: currentId,
        date: event.date
      }, {
        type: 'temp_end',
        id: currentId,
        date: event.end
      });
    } else {
      currentId++;
      permanentMapping.set(currentId, getInput(event.info));
      eventsTimeline.push({
        type: 'permanent',
        id: currentId,
        date: event.date
      });
    } 
  });

  // sort needs to be a bit more than just the date;
  // if on the same day, the priority is permanent->temp end->temp start
  const sorted = eventsTimeline.sort((a, b) => {
    const aVersion = a.date;
    const bVersion = b.date;
    if (isLower(aVersion, bVersion)) {
      return -1;
    } else if (isEqual(aVersion, bVersion)) {
      if (a.type === b.type) {
        return 0;
      }
      if (a.type === 'permanent') {
        return -1;
      }
      if (b.type === 'permanent') {
        return 1;
      }
      if (a.type === 'temp_end') {
        return -1;
      }
      if (b.type === 'temp_end') {
        return 1;
      }
      return 0;
    } else {
      return 1;
    }
  });

  // second part of this algorithm: going through the events
  // and judging which file is to be used at each date

  const versions: Array<{ 
    date: Version
    out: EventOutput
    id: number
  }> = [];

  let previousPermanent = -1;
  let currentPermanent = -1;
  // this acts as a queue, so there can be multiple temporary events
  let currentTemporaries: number[] = [];

  // we will assign IDs to the output so that we can tell which of the outputs
  // represent the exact same state (discerned via the "hashing" function)
  let outputId = 0;
  const outputs = new Map<string, number>();

  const getOutputId = (output: EventOutput) => {
    const hash = hashOutput(output);
    const id = outputs.get(hash);
    
    if (id === undefined) {
      outputId++;
      outputs.set(hash, outputId);
      return outputId;
    } else {
      return id;
    }
  }

  // maps id of permanent update and the output generated by it
  const outputMapping = new Map<number, EventOutput>();
  
  const getPrevious = () => {
    let previous = outputMapping.get(previousPermanent);
    if (previous === undefined) {
      return getFirstOutput();
    }
    return previous;
  }

  const pushPermanent = (date: string) => {
    const input = permanentMapping.get(currentPermanent);
    if (input !== undefined) {
      // no permanent room means there isn't one. So no changes will be used
      const output = getOutput(getPrevious(), input);
      outputMapping.set(currentPermanent, output);
      const id = getOutputId(output);
      versions.push({
        date,
        out: output,
        id
      });
    }
  }

  const pushTemporary = (date: string) => {
    const currentTemporary = currentTemporaries[0];
    const input = temporaryMapping.get(currentTemporary);
    if (input === undefined) {
      throw new Error('Logic error');
    }
    const output = getOutput(getPrevious(), input);
    const id = getOutputId(output);
    versions.push({
      date,
      out: output,
      id
    });
  }

  sorted.forEach((event) => {
    if (event.type === 'permanent') {
      previousPermanent = currentPermanent;
      currentPermanent = event.id;
      // permanent changes take effect once the temporaries are gone
      if (currentTemporaries.length === 0) {
        pushPermanent(event.date);
      }
    } else if (event.type === 'temp_start') {
      currentTemporaries.unshift(event.id);
      pushTemporary(event.date);
    } else if (event.type === 'temp_end') {
      currentTemporaries = currentTemporaries.filter((id) => id !== event.id);
      if (currentTemporaries.length === 0) {
        pushPermanent(event.date);
      } else {
        pushTemporary(event.date);
      }
    }
  });

  return versions;
}

type VersionsInformation<EventInformation> = Array<{
  date: Version;
  info: EventInformation
}>

export function processTimeInvariantTimeline<EventInformation>(timeline: TimelineEvent<EventInformation>[]) {
  const versions = processTimeline<EventInformation, EventInformation, undefined | EventInformation>(timeline, (input) => {
    return input;
  }, () => {
    return undefined
  }, (_, c) => c, (out) => out === undefined ? '' : JSON.stringify(out));

  const cleanVersions: Array<{
    date: Version;
    info: EventInformation;
  }> = [];
  versions.forEach((version) => {
    if (version.out !== undefined) {
      cleanVersions.push({ date: version.date, info: version.out });
    }
  })

  return cleanVersions;
}

/** Maps a route to all the file information related to it */
export type IdentifierMap<Identifier, VersionsInformation> = Map<Identifier, VersionsInformation>;

/** Given a route map, adds file information to a given route */
export function addToIdentifierMap<Identifier, EventInformation>(
  map: IdentifierMap<Identifier, EventInformation>,
  identifier: Identifier,
  info: EventInformation
): void {
  const previousValue = map.get(identifier);
  if (previousValue === undefined) {
    map.set(identifier, info);
  } else {
    console.log(previousValue, info);
    throw new Error(`${identifier} is being duplicated`);
  }
}

export class TimelineMap<Identifier, EventInformation> {
  private _map: Map<Identifier, TimelineEvent<EventInformation>[]>;
  
  constructor() {
    this._map = new Map<Identifier, TimelineEvent<EventInformation>[]>;
  }

  addTemp(identifier: Identifier, start: Version, end: Version, info: EventInformation) {
    this.add(identifier, {
      date: start,
      end,
      info
    });
  }
  addPerm(identifier: Identifier, date: Version, info: EventInformation) {
    this.add(identifier, {
      date,
      info,
    });
  }

  /** Add a file update event to a timeline map for a given route */
  private add(identifier: Identifier, event: TimelineEvent<EventInformation>): void {
    const prev = this._map.get(identifier);
    if (prev === undefined) {
      this._map.set(identifier, [event]);
    } else {
      prev.push(event);
    }
  }

  getIdentifierMap(): Map<Identifier, VersionsInformation<EventInformation>> {
    const idMap = new Map<Identifier, VersionsInformation<EventInformation>>();
    this._map.forEach((timeline, route) => {
      addToIdentifierMap(idMap, route, processTimeInvariantTimeline(timeline))
    });

    return idMap;
  }
}