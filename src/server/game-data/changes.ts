import { iterateEntries } from "../../common/utils";
import { isEqual, isLower, Version } from "../routes/versions"
import { FileRef } from "./files";

/** A map that takes as keys a game route and as values a file reference */
export type RouteRefMap = Record<string, FileRef>;

/**
 * A map that takes as keys versions, and as values information of a certain type, used for
 * permanent changes
 * */
export type DateMap<Info> = Record<Version, Info>;

export type DateRefMap = DateMap<FileRef>;

/** A map that takes as keys a ID number (of any kind) and values a file reference */
export type IdRefMap = Record<number, FileRef>;

export type PermanentChange<ChangeInformation> = {
  date: Version;
  info: ChangeInformation
};

export type TemporaryChange<ChangeInformation> = {
  date: Version;
  end: Version;
  info: ChangeInformation;
  updates: Array<PermanentChange<ChangeInformation>>;
};

/** Abstraction of a type that represents either a temporary event or permanent one in a timeline */
export type TimelineEvent<ChangeInformation> = PermanentChange<ChangeInformation> | TemporaryChange<ChangeInformation>;

export type PermanentUpdateTimeline<UpdateInformation> = Array<{
  date: Version;
} & UpdateInformation>;

/**
 * Processes a timeline of events into some form of output
 * @param timeline The timeline of events
 * @param getInput A function that takes each event and gets characteristic input data that is meant to be particular of each event
 * @param getOutput A function that takes a previous' event input data, or none if nothing previous, and the current event input data and outputs a final output
 * @param hashOutput A function that creates a unique identifier for a given output, to be able to hash it
 * @returns 
 */
export function processTimeline<EventInformation, EventInput, EventOutput>(
  timeline: TimelineEvent<EventInformation>[],
  getInput: <T extends EventInformation>(input: T) => EventInput,
  getFirstOutput: () => EventOutput,
  getOutput: (prev: EventOutput, cur: EventInput) => EventOutput,
  hashOutput: (out: EventOutput) => string
): Array<{
  date: Version,
  out: EventOutput,
  id: number
}> {
  // first part of this altgothrm:
  // labeling what each update is and breaking everything down
  // to events
  
  // get id of event input so we can find them later
  const permanentMapping = new Map<number, EventInput>();
  const temporaryMapping = new Map<number, EventInput>();

  const eventsTimeline: Array<{
    type: 'permanent' | 'temp_start' | 'temp_end',
    id: number;
    date: Version;
  }> = [];

  let currentId = 0;

  timeline.forEach((event) => {
    if ('end' in event) {
      currentId++;
      temporaryMapping.set(currentId, getInput(event.info));
      eventsTimeline.push({
        type: 'temp_start',
        id: currentId,
        date: event.date
      }, {
        type: 'temp_end',
        id: currentId,
        date: event.end
      });
    } else {
      currentId++;
      permanentMapping.set(currentId, getInput(event.info));
      eventsTimeline.push({
        type: 'permanent',
        id: currentId,
        date: event.date
      });
    } 
  });

  // sort needs to be a bit more than just the date;
  // if on the same day, the priority is permanent->temp end->temp start
  const sorted = eventsTimeline.sort((a, b) => {
    const aVersion = a.date;
    const bVersion = b.date;
    if (isLower(aVersion, bVersion)) {
      return -1;
    } else if (isEqual(aVersion, bVersion)) {
      if (a.type === b.type) {
        return 0;
      }
      if (a.type === 'permanent') {
        return -1;
      }
      if (b.type === 'permanent') {
        return 1;
      }
      if (a.type === 'temp_end') {
        return -1;
      }
      if (b.type === 'temp_end') {
        return 1;
      }
      return 0;
    } else {
      return 1;
    }
  });

  // second part of this algorithm: going through the events
  // and judging which file is to be used at each date

  const versions: Array<{ 
    date: Version
    out: EventOutput
    id: number
  }> = [];

  let previousPermanent = -1;
  let currentPermanent = -1;
  // this acts as a queue, so there can be multiple temporary events
  let currentTemporaries: number[] = [];

  // we will assign IDs to the output so that we can tell which of the outputs
  // represent the exact same state (discerned via the "hashing" function)
  let outputId = 0;
  const outputs = new Map<string, number>();

  const getOutputId = (output: EventOutput) => {
    const hash = hashOutput(output);
    const id = outputs.get(hash);
    
    if (id === undefined) {
      outputId++;
      outputs.set(hash, outputId);
      return outputId;
    } else {
      return id;
    }
  }

  // maps id of permanent update and the output generated by it
  const outputMapping = new Map<number, EventOutput>();
  
  const getPrevious = () => {
    let previous = outputMapping.get(previousPermanent);
    if (previous === undefined) {
      return getFirstOutput();
    }
    return previous;
  }

  const pushPermanent = (date: string) => {
    const input = permanentMapping.get(currentPermanent);
    if (input !== undefined) {
      // no permanent room means there isn't one. So no changes will be used
      const output = getOutput(getPrevious(), input);
      outputMapping.set(currentPermanent, output);
      const id = getOutputId(output);
      versions.push({
        date,
        out: output,
        id
      });
    }
  }

  const pushTemporary = (date: string) => {
    const currentTemporary = currentTemporaries[0];
    const input = temporaryMapping.get(currentTemporary);
    if (input === undefined) {
      throw new Error('Logic error');
    }
    const output = getOutput(getPrevious(), input);
    const id = getOutputId(output);
    versions.push({
      date,
      out: output,
      id
    });
  }

  sorted.forEach((event) => {
    if (event.type === 'permanent') {
      previousPermanent = currentPermanent;
      currentPermanent = event.id;
      // permanent changes take effect once the temporaries are gone
      if (currentTemporaries.length === 0) {
        pushPermanent(event.date);
      }
    } else if (event.type === 'temp_start') {
      currentTemporaries.unshift(event.id);
      pushTemporary(event.date);
    } else if (event.type === 'temp_end') {
      currentTemporaries = currentTemporaries.filter((id) => id !== event.id);
      if (currentTemporaries.length === 0) {
        pushPermanent(event.date);
      } else {
        pushTemporary(event.date);
      }
    }
  });

  return versions;
}

type VersionsInformation<EventInformation> = Array<{
  date: Version;
  info: EventInformation
}>;

export function processTimeInvariantTimeline<EventInformation>(timeline: TimelineEvent<EventInformation>[]) {
  const versions = processTimeline<EventInformation, EventInformation, undefined | EventInformation>(timeline, (input) => {
    return input;
  }, () => {
    return undefined
  }, (_, c) => c, (out) => out === undefined ? '' : JSON.stringify(out));

  const cleanVersions: Array<{
    date: Version;
    info: EventInformation;
  }> = [];
  versions.forEach((version) => {
    if (version.out !== undefined) {
      cleanVersions.push({ date: version.date, info: version.out });
    }
  })

  return cleanVersions;
}

export function baseFindInVersion<Prop extends string, ValueType, T extends { date: Version } & { [key in Prop]: ValueType }>(date: Version, versions: T[], propName: Prop) {
  if (versions.length === 1) {
    return versions[0][propName];
  }
  
  const index = findEarliestDateHitIndex(date, versions);
  if (index === -1) {
    return undefined;
  }
  
  return versions[index][propName];
}

export function findInVersion<EventInformation>(date: Version, versions: VersionsInformation<EventInformation>) {
  return baseFindInVersion(date, versions, 'info');
}

export function getIdentifierInMap<Identifier, EventInformation>(
  map: IdentifierMap<Identifier, EventInformation>,
  id: Identifier,
  date: Version
) {
  const versions = map.get(id);
  if (versions === undefined) {
    return null;
  }
  return findInVersion(date, versions);
}

export function findEarliestDateHitIndex<T extends { date: Version }>(date: Version, array: T[]): number {
  if (array.length < 2) {
    if (array.length === 1) {
      if (isLower(date, array[0].date)) {
        return -1
      } else {
        return 0;
      }
    } else {
      // empty array
      return -1;
    }
  }

  let left = 0;
  // the last index is not allowed since we search in pairs
  // and then -1 because length is last index + 1
  let right = array.length - 2;
  let index = -1;
  
  // this is a type of binary search implementation
  while (true) {
    // this means that was lower than index 0
    if (right === -1) {
      index = -1;
      break
    } else if (left === array.length - 1) {
      // this means that was higher than last index
      index = left;
      break;
    }
    const middle = Math.floor((left + right) / 2);
    const element = array[middle];
    if (isLower(date, element.date)) {
      // middle can't be it, but middle - 1 could still be
      right = middle - 1;
    } else if (isLower(date, array[middle + 1].date)) {
      index = middle;
      break;
    } else {
      left = middle + 1;
    }
  }

  return index;
}

/** Maps a route to all the file information related to it */
export type IdentifierMap<Identifier, EventInformation> = Map<Identifier, VersionsInformation<EventInformation>>;

/** Given a route map, adds file information to a given route */
export function addToIdentifierMap<Identifier, EventInformation>(
  map: IdentifierMap<Identifier, EventInformation>,
  identifier: Identifier,
  info: { date: Version; info: EventInformation }[]
): void {
  const previousValue = map.get(identifier);
  if (previousValue === undefined) {
    map.set(identifier, info);
  } else {
    console.log(previousValue, info);
    throw new Error(`${identifier} is being duplicated`);
  }
}

export class VersionsTimeline<EventInformation> {
  private _eventsTimeline: TimelineEvent<EventInformation>[];
  
  constructor() {
    this._eventsTimeline = [];
  }

  addDateMap(dateMap: DateMap<EventInformation>) {
    iterateEntries(dateMap, (date, info) => {
      this.add({ date, info });
    })
  }

  add(event: TimelineEvent<EventInformation>) {
    this._eventsTimeline.push(event);
  }

  getVersion() {
    return processTimeInvariantTimeline(this._eventsTimeline);
  }
}

export class TimelineMap<Identifier, EventInformation> {
  private _map: Map<Identifier, VersionsTimeline<EventInformation>>;
  
  constructor() {
    this._map = new Map<Identifier, VersionsTimeline<EventInformation>>;
  }

  /** Inherit to make changes to the identifier input */
  protected processIdentifier(identifier: Identifier): Identifier {
    return identifier;
  }

  /** Inherit to make changes to the information input */
  protected processInformation(info: EventInformation): EventInformation {
    return info;
  }

  addDateMap(id: Identifier, dateMap: DateMap<EventInformation>): void {
    this.updateIdentifier(id, (t) => t.addDateMap(dateMap));
  }

  updateIdentifier(id: Identifier, updater: (timeline: VersionsTimeline<EventInformation>) => void) {
    id = this.processIdentifier(id);
    let timeline = this._map.get(id);
    if (timeline === undefined) {
      timeline = new VersionsTimeline<EventInformation>();
    }

    updater(timeline);
  }

  addTemp(identifier: Identifier, start: Version, end: Version, info: EventInformation) {
    this.add(identifier, {
      date: start,
      end,
      info
    });
  }
  addPerm(identifier: Identifier, date: Version, info: EventInformation) {
    this.add(identifier, {
      date,
      info,
    });
  }

  /** Add a file update event to a timeline map for a given route */
  protected add(identifier: Identifier, event: TimelineEvent<EventInformation>): void {
    identifier = this.processIdentifier(identifier);
    event.info = this.processInformation(event.info);
    const prev = this._map.get(identifier);
    if (prev === undefined) {
      const timeline = new VersionsTimeline<EventInformation>();
      timeline.add(event);
      this._map.set(identifier, timeline);
    } else {
      prev.add(event);
    }
  }

  getIdentifierMap(): Map<Identifier, VersionsInformation<EventInformation>> {
    const idMap = new Map<Identifier, VersionsInformation<EventInformation>>();
    this._map.forEach((timeline, route) => {
      addToIdentifierMap(idMap, route, timeline.getVersion());
    });

    return idMap;
  }
}